PubNub channel topology
PubNub channel topology (MVP, finalized)
Identifiers
â—	gameId: 8-char random alphanumeric (example: A7K2Q9XJ)â€¨
â—	playerId: unique per player (UUID or short random; your choice)â€¨

Channel 1: Player moves (input)
game.[gameId]
Who publishes: Player clientsâ€¨ Who processes: PubNub Functions â€œBefore Publishâ€ bound to game.*â€¨ Who subscribes (clients): Optional (not required for MVP)
Purpose
â—	Players publish their move intents (swap / resulting positions).â€¨
â—	The Before Publish function:â€¨
â—‹	validates move + game state (KV Store)â€¨
â—‹	updates KV Store (player board, move count, correctness history, timestamps)â€¨
â—‹	determines win + lockoutâ€¨
â—‹	publishes the authoritative â€œprogress/eventâ€ message to admin.[gameId]â€¨
Key MVP rule
â—	After GAME_OVER (KV: locked), the function blocks/ignores any further moves.â€¨

Channel 2: Admin broadcast (output)
admin.[gameId]
Who publishes: PubNub Functions (from the Before Publish handler)â€¨ Who subscribes: All player clients (direct subscribe; multiplex is fine)â€¨ Purpose
â—	The only channel players must subscribe to during gameplay.â€¨
â—	Broadcasts everything players need to render:â€¨
â—‹	countdown + startâ€¨
â—‹	full per-player boards + correctness history (you confirmed shared visibility is OK)â€¨
â—‹	winner + lockout + end messagesâ€¨

Functions and state (where logic lives)
A) Before Publish Function
Binding: channel pattern game.*â€¨ Responsibilities (MVP):
â—	Load game + player state from KV Storeâ€¨
â—	Validate:â€¨
â—‹	game exists, started/locked flagsâ€¨
â—‹	player is part of roster (no late joins)â€¨
â—‹	move payload is well-formedâ€¨
â—	Apply swap, increment moves, compute correctness count, append correctness historyâ€¨
â—	If correctness == 4:â€¨
â—‹	set game lockedâ€¨
â—‹	record winner using PubNub 17-digit timetoken orderingâ€¨
â—‹	publish GAME_OVER to admin.[gameId]â€¨
â—	Else publish PROGRESS_UPDATE (or equivalent) to admin.[gameId]â€¨
B) KV Store (single source of truth)
â—	Stores:â€¨
â—‹	goal orderâ€¨
â—‹	per-player current boardâ€¨
â—‹	per-player moves + correctness historyâ€¨
â—‹	started/locked flagsâ€¨
â—‹	roster (fixed at start; no late joins)â€¨
â—‹	winner (when set)â€¨

Client subscription model
â—	Subscribe to exactly: admin.[gameId]â€¨
â—	Publish moves to: game.[gameId]â€¨
â—	No Presence, no PAM, no channel groups, no wildcard subscribe (per your MVP constraints).

Message Schemas
Finalized Decisions (Locked)
â—	Tile IDs: 0â€“3 (confirmed)â€¨
â—	Emoji mapping: sent at GAME_STARTâ€¨
â—	Goal order:â€¨
â—‹	âŒ Never sent to clients during gameplayâ€¨
â—‹	âœ… Sent only in GAME_OVERâ€¨
â—	Initial order:â€¨
â—‹	Same for all playersâ€¨
â—‹	Guaranteed 0 positions correctâ€¨
â—	Move processing:â€¨
â—‹	Client publishes â†’ game.[gameId]â€¨
â—‹	Before Publish Function processes + mutates KVâ€¨
â—	Progress updates:â€¨
â—‹	Sent to game.[gameId]â€¨
â—‹	One player per message (no full snapshots)â€¨
â—	Game over:â€¨
â—‹	Winner ID + goal order onlyâ€¨
â—	Post-game moves: silently ignoredâ€¨
No ambiguity remains.

ğŸ“¡ Final Message Contract Summary (Canonical)
Channel: game.[gameId]
MOVE_SUBMIT (client â†’ function)
{
  "v": 1,
  "type": "MOVE_SUBMIT",
  "gameId": "A7K2Q9XJ",
  "playerId": "p1",
  "order": { "a": 1, "b": 3, "c": 2, "d": 0 },
  "clientMoveSeq": 8,
  "ts": 1766512345678
}

Rules enforced by Before Publish:
â—	Order must be a permutation of {0,1,2,3}â€¨
â—	Game must be LIVEâ€¨
â—	Move increments player move countâ€¨
â—	Positions compared against hidden goal orderâ€¨
â—	Ignore entirely if game is LOCKEDâ€¨

PROGRESS_UPDATE (function â†’ game channel)
{
  "v": 1,
  "type": "PROGRESS_UPDATE",
  "gameId": "A7K2Q9XJ",
  "playerId": "p1",
  "moveCount": 8,
  "positionsCorrect": 3,
  "moveTT": "17665123456799999"
}

Clients use this to:
â—	Update scoreboardâ€¨
â—	Append correctness historyâ€¨
â—	Detect â€œsomeone finishedâ€ indirectly (but not winner yet)â€¨

Channel: admin.[gameId]
GAME_START
{
  "v": 1,
  "type": "GAME_START",
  "gameId": "A7K2Q9XJ",
  "phase": "LIVE",
  "tiles": {
    "0": "ğŸ•",
    "1": "ğŸš€",
    "2": "ğŸ¶",
    "3": "ğŸ¸"
  },
  "initialOrder": { "a": 2, "b": 0, "c": 3, "d": 1 },
  "startTT": "17665123456789012"
}

âœ” Goal order not included

GAME_OVER
{
  "v": 1,
  "type": "GAME_OVER",
  "gameId": "A7K2Q9XJ",
  "phase": "LOCKED",
  "winnerPlayerId": "p2",
  "goalOrder": { "a": 0, "b": 1, "c": 2, "d": 3 },
  "winTT": "17665123456800001"
}

âœ” First and only time the goal order is revealedâ€¨ âœ” Used by losing clients to overlay the solution

ğŸ”’ At This Point
You now have:
â—	A minimal, non-overengineered PubNub topologyâ€¨
â—	Before Publishâ€“centric authorityâ€¨
â—	Deterministic multiplayer resolutionâ€¨
â—	Schemas Claude can implement without inventing behavior

Server State Machines (Final MVP)
Server State Machines (Final MVP)
Channels recap
â—	game.[gameId]: client publishes MOVE_SUBMIT and START_GAME; Function publishes PROGRESS_UPDATE (back to same channel)â€¨
â—	admin.[gameId]: Function publishes COUNTDOWN (optional), GAME_START, GAME_OVERâ€¨
Everything is KV-backed and Before Publish is bound to game.*.

1) Game lifecycle state machine
States
â—	CREATED: game exists, roster set (or still being assembled), not startedâ€¨
â—	LIVE: accepts movesâ€¨
â—	LOCKED: game over; ignore everythingâ€¨
(Countdown is an action sequence, not a required state.)
Transitions
CREATED â†’ LIVE (triggered by START_GAME from any player)
Trigger message: START_GAME published to game.[gameId] by any player.
Guard conditions (KV):
â—	game.phase == CREATEDâ€¨
â—	playerId âˆˆ game.players (or ignore if not in roster)â€¨
Actions (atomic intent; best-effort KV):
1.	Generate tiles mapping (tileId 0â€“3 â†’ emoji)â€¨
2.	Generate goalOrder (hidden)â€¨
3.	Generate initialOrder such that:â€¨
â—‹	It is a permutation of {0,1,2,3}â€¨
â—‹	It has 0 positions correct vs goalOrderâ€¨
â—‹	It is the same initialOrder for all playersâ€¨
4.	Initialize each player record:â€¨
â—‹	moveCount = 0â€¨
â—‹	currentOrder = initialOrderâ€¨
â—‹	correctnessHistory = []â€¨
â—‹	positionsCorrect = 0â€¨
â—‹	finished = false, finishTT = nullâ€¨
5.	Publish to admin.[gameId]:â€¨
â—‹	optional countdown ticksâ€¨
â—‹	GAME_START with {tiles, initialOrder, startTT}â€¨
6.	Update game KV:â€¨
â—‹	phase = LIVEâ€¨
â—‹	startTT = <GAME_START publish timetoken>â€¨
Idempotency / race handling (since anyone can start):
â—	If multiple START_GAME messages arrive close together:â€¨
â—‹	Only the first one that observes phase == CREATED performs initialization.â€¨
â—‹	Others see phase != CREATED and are ignored.â€¨

LIVE â†’ LOCKED (triggered by a winning MOVE_SUBMIT)
Trigger: a processed move yields positionsCorrect == 4.
Guard:
â—	game.phase == LIVEâ€¨
Actions:
1.	Mark player finished:â€¨
â—‹	finished = trueâ€¨
â—‹	finishTT = moveTTâ€¨
2.	Winner resolution:â€¨
â—‹	If game.winnerPlayerId is null: set winner to this player with winTT = moveTTâ€¨
â—‹	If somehow already set: keep the earliest winTT (lower timetoken)â€¨
3.	Lock:â€¨
â—‹	game.phase = LOCKEDâ€¨
â—‹	game.lockedTT = nowTTâ€¨
4.	Publish GAME_OVER to admin.[gameId] containing:â€¨
â—‹	winnerPlayerIdâ€¨
â—‹	goalOrder (first time revealed)â€¨
â—‹	winTTâ€¨
5.	After lock, ignore all future messages on game.[gameId] (moves or start attempts)â€¨

2) Before Publish handler state machine (bound to game.*)
The handler inspects message.type and routes logic:
Event types handled on game.[gameId]
â—	START_GAME (client â†’)â€¨
â—	MOVE_SUBMIT (client â†’)â€¨
â—	PROGRESS_UPDATE (function â†’, but you can ignore/let pass through)â€¨
A) START_GAME processing
Input:
{ "v":1, "type":"START_GAME", "gameId":"A7K2Q9XJ", "playerId":"p1" }

Algorithm (summary):
1.	Load game from KVâ€¨
2.	If missing OR phase != CREATED: ignoreâ€¨
3.	If playerId not in roster: ignoreâ€¨
4.	Initialize game + players as described aboveâ€¨
5.	Publish GAME_START (and optional countdown) on admin.[gameId]â€¨
6.	Set phase=LIVEâ€¨
Output messages:
â—	Only admin.[gameId] gets lifecycle events.â€¨

B) MOVE_SUBMIT processing
Input: (full order submission)
{
  "v": 1,
  "type": "MOVE_SUBMIT",
  "gameId": "A7K2Q9XJ",
  "playerId": "p1",
  "order": { "a": 1, "b": 3, "c": 2, "d": 0 }
}

Guards (ignore if any fail):
â—	game existsâ€¨
â—	game.phase == LIVEâ€¨
â—	playerId in rosterâ€¨
â—	order is a valid permutation of {0,1,2,3}â€¨
Actions:
1.	player.currentOrder = orderâ€¨
2.	player.moveCount += 1â€¨
3.	positionsCorrect = matchCount(order, goalOrder)â€¨
4.	Append to player.correctnessHistoryâ€¨
5.	Persist player KVâ€¨
6.	Publish PROGRESS_UPDATE to game.[gameId]:â€¨
â—‹	{playerId, moveCount, positionsCorrect, moveTT}â€¨
If positionsCorrect == 4:
â—	Lock game + publish GAME_OVER to admin.[gameId] as described.â€¨
Post-game:
â—	If game.phase == LOCKED: ignore silently (your rule #2).â€¨

3) Minimal START_GAME message contract (new)
On game.[gameId]
{
  "v": 1,
  "type": "START_GAME",
  "gameId": "A7K2Q9XJ",
  "playerId": "p1",
  "ts": 1766512345678
}

No response on game for start; clients wait for GAME_START on admin.

4) Client UI state machine expectations (for implementation clarity)
Lobby/Pre-start
â—	Subscribe to:â€¨
â—‹	admin.[gameId]â€¨
â—‹	game.[gameId] (for progress updates later; can subscribe now or on start)â€¨
â—	Show â€œStart Gameâ€ buttonâ€¨
â—	On click:â€¨
â—‹	publish START_GAME to game.[gameId]â€¨
â—	Wait for GAME_START on admin.[gameId]â€¨
Live
â—	Render tiles + initial order from GAME_STARTâ€¨
â—	On move completion:â€¨
â—‹	publish MOVE_SUBMIT with full orderâ€¨
â—	Update scoreboard/history on each PROGRESS_UPDATE from game.[gameId]â€¨
Locked
â—	On GAME_OVER from admin.[gameId]:â€¨
â—‹	disable inputâ€¨
â—‹	overlay goalOrder over each playerâ€™s last known orderâ€¨
â—‹	show win/lose messageâ€¨


Claude Guardrail Checklist
Claude Guardrail Checklist (Swap It! MVP)
A) Do-not-drift scope locks
â—	Implement only the MVP features explicitly specified.
â—	Do not add: auth, PAM, presence, channel groups, wildcards, leaderboards, storage beyond KV, spectator mode, replays.
â—	Keep exactly two channels:
â—‹	game.[gameId]
â—‹	admin.[gameId]
â—	Use PubNub MCP servers for all PubNub provisioning/config (account/keyset/functions/KV).
â—	Do not hardcode PubNub keys; assume MCP provisions securely.
B) Message schema compliance (no â€œcreativeâ€ fields)
â—	Every message includes: v, type, gameId.
â—	Enforce tile IDs are 0â€“3 everywhere (KV, orders, comparisons, UI).
â—	MOVE_SUBMIT must send full order only (no swap field).
â—	PROGRESS_UPDATE must include only:
â—‹	playerId
â—‹	moveCount
â—‹	positionsCorrect
â—‹	moveTT
â—‹	(plus v/type/gameId)
â—	GAME_START must include:
â—‹	tiles mapping 0â€“3 -> emoji
â—‹	initialOrder
â—‹	startTT
â—‹	phase: LIVE
â—	GAME_OVER must include:
â—‹	winnerPlayerId
â—‹	goalOrder
â—‹	winTT
â—‹	phase: LOCKED
â—	Do not introduce new message types unless explicitly approved.
C) Goal secrecy & reveal timing
â—	The goalOrder must be stored only in KV (server-side).
â—	Never send goalOrder to clients during gameplay.
â—	Send goalOrder only in GAME_OVER.
D) Initial order constraints
â—	All players must start with the same initialOrder.
â—	initialOrder must have 0 positions correct vs goalOrder.
â—	initialOrder is sent only in GAME_START.
E) Server authority & function routing
â—	All game logic runs in Before Publish bound to game.*.
â—	Clients do not compute correctness; they only submit orders.
â—	Client publishes:
â—‹	START_GAME to game.[gameId]
â—‹	MOVE_SUBMIT to game.[gameId]
â—	Function publishes:
â—‹	PROGRESS_UPDATE to game.[gameId]
â—‹	GAME_START / optional COUNTDOWN / GAME_OVER to admin.[gameId]
F) State machine invariants
â—	Game phases are exactly: CREATED, LIVE, LOCKED.
â—	START_GAME:
â—‹	Any player may trigger it
â—‹	Only works if phase == CREATED
â—‹	If already started, ignore silently
â—	MOVE_SUBMIT:
â—‹	Only processed if phase == LIVE
â—‹	If phase == LOCKED, ignore silently
â—‹	If invalid payload/order, ignore silently
G) Winner resolution (no ties)
â—	Determine winner using PubNub 17-digit timetoken ordering.
â—	Lock the game immediately after first win is recorded.
â—	After lock, ignore all subsequent moves (no REJECTED message).
H) KV store discipline
â—	KV is the only state source. No in-memory reliance for correctness.
â—	Use deterministic KV keys:
â—‹	swapit:game:{gameId}
â—‹	swapit:game:{gameId}:player:{playerId}
â—	Store per-player:
â—‹	currentOrder, moveCount, positionsCorrect, correctnessHistory, finished, finishTT
â—	Store per-game:
â—‹	phase, tiles, goalOrder, initialOrder, players[], winnerPlayerId, startTT, winTT
I) Client UI behavior locks
â—	Client subscribes directly to:
â—‹	game.[gameId]
â—‹	admin.[gameId]
â—	Start Game button visible to all pre-start; clicking publishes START_GAME.
â—	Selection UX:
â—‹	Click same emoji twice = unselect
â—‹	Second distinct click submits a move (full order)
â—	Animate swaps.
â—	Show correctness history (append per PROGRESS_UPDATE).
â—	On GAME_OVER:
â—‹	Lock UI input immediately
â—‹	Winner message: â€œWINNER! WINNER! CHICKEN DINNER!â€
â—‹	Loser message: â€œYOU LOSE! BE FASTER NEXT TIME!â€
â—‹	Overlay goalOrder onto each playerâ€™s current order
J) Output expectations (donâ€™t omit)
â—	Provide runnable React app + instructions.
â—	Provide Before Publish function code (deployable via MCP flow).
â—	Provide KV initialization strategy.
â—	Provide MCP steps to create/configure PubNub resources.
â—	No credentials requested or embedded.
K) Self-check before final response
Before presenting the final implementation, Claude must:
â—	List the two channels and confirm no others exist.
â—	Show one example JSON for each message type and confirm exact fields.
â—	Confirm goalOrder is not emitted before GAME_OVER.
â—	Confirm invalid and post-LOCK moves are ignored silently.
â—	Confirm tile IDs are 0â€“3 everywhere.

